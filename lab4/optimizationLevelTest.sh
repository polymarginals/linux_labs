#!/bin/sh

# Этот скрипт нужно запускать первым.
# В ходе своей работы, он будет компилировать и запускать нашу программу с разными ключами оптимизации,
# замерять время, которое исполнялась программа с тем или иным ключом оптимизации, и выводить на экран.
# По окончании его работы, ты должна будешь просмотреть полученные результаты и найти ключ, при котором время исполнения
# было бы наименьшим. Этот ключ надо будет запомнить, и перенести во второй скрипт (optimizationOptionTest)

# Запускается данный скрипт через ./optimizationLevelTest test.cpp
# где test.cpp мы передаём в качестве аргумента командой строки.

# В этом скрипте мы компилируем и запускаем нашу программу (test.cpp) с разными ключами уровней оптимизации.
# Все доступные ключи уровней оптимизации перечисленны в множестве ниже.

# это цикл for по переменной i. Переменная i итерируется по множеству, указанному через запятую после слова in.
# Это означает, что есть массив значений ("-O0", "-Os", "-O1" и тд), и по этому массиву мы проходимся циклом.
for i in "-O0" "-Os" "-O1" "-O2" "-O3" "-O2 -march=native" "-O3 -march=native" "-O2 -march=native -funroll-loops" "-O3 -march=native -funroll-loops"
do    # начало тела цикла
  echo ""                               # выводим пустую строку, для визуального отделения на экране терминала.
  echo "Using $i optimization level..." # сообщение о том, какой именно на текущей итерации
                                        # используется уровень оптимизации.

  # Этой командой мы компилируем нашу программу, используя компилятор g++
  g++ $i $1 -o OptimizationLvl -lm  # вместо $i будет подставлен ключ уровня оптимизации, например g++ -O3 -march=native
                                    # вместо $1 будет подставлен аргумент командной строки (мы передаём туда нашу
                                    # программу, когда запускаем этот скрипт: ./optimizationLevelTest.sh test.cpp )
                                    # -o OptimizationLvl -- этот ключ говорит о том, как назвать получившийся
                                    # исполняемый файл, в нашем случае, в результате компиляции мы получим файл
                                    # OptimizationLvl

  # Программа time запускает какую-то другую программу (в нашем случае нашу скомпилированную только что OptimizationLvl)
  # и считает её время выполнения. После того, как программа, переданная time как аргумент (OptimizationLvl) будет
  # исполнена, time выведет на консоль время, затраченное на исполнение.
  time -p ./OptimizationLvl
  echo "Executable file storage usage:" # выводим место, которое занимает исполняемый файл
  # из документации по du (man du)
  # du: estimate file space usage. (т.е. du вычисляет занимаемое пространство файлом)
  # -h, --human-readable: sizes in human readable format (e.g., 1K 234M 2G) (т.е. вывод в читаемом формате)
  du -h ./OptimizationLvl

  # просто две пустые строчки для отделения текста.
  printf '\n\n'
done  # конец тела цикла

# по окончании цикла, выводим Done.
echo "Done."
