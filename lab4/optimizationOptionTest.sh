#!/bin/sh

# Этот скрипт нужно запускать вторым.
# В ходе своей работы, он будет компилировать и запускать нашу программу с лучшим ключом оптимизации, который
# ты должна получить из первого скрипта, добавляя к нему одному всякие возможные ещё опции (перечисленны ниже в цикле).
# Скрипт также будет замерять время, которое исполнялась программа с тем или иным ключом оптимизации, и выводить на
# экран. По окончании его работы, ты должна будешь просмотреть полученные результаты и найти опцию, при которой время
# исполнения программы было бы наименьшим.
# Тогда, в конечном счёте, ты будешь иметь самый оптимальный ключ (из первого скрипта)
# и самую оптимальную опцию, из этого скрипта. Если объеденить их вместе -- то это самый оптимальный для тебя вариант
# компиляции программ на C++.

# Запускается данный скрипт через ./optimizationOptionTest test.cpp
# где test.cpp мы передаём в качестве аргумента командой строки.

# этот вывод у тебя будет свой. Здесь я вывожу лучший по времени ключ оптимизации,
# полученный из результатов выполнения первого скрипта, optimizationLevelTest.
echo "Best optimization option: -O2 -march=native"

# Это цикл for по переменной i. Переменная i итерируется по множеству, указанному через запятую после слова in.
# Это означает, что есть массив значений ("-fipa-pta -flto", "-fprofile-use", "-fipa-pta -flto" и тд),
# и по этому массиву мы проходимся циклом.
for i in "-fipa-pta -flto" "-fprofile-generate" "-fprofile-use" "-fipa-pta -flto -fprofile-generate" "-fipa-pta -flto -fprofile-use"
do    # начало тела цикла
  echo ""                           # выводим пустую строку, для визуального отделения на экране терминала.
  echo "Optimization options: $i"   # сообщение о том, какая именно на текущей итерации
                                    # используется опция оптимизации.

  # Этой командой мы компилируем нашу программу, используя компилятор g++ и заданные ключ и опцию оптимизации.
  g++ -O2 -march=native $i $1 -o OptimizationOption # ВАЖНО: здесь вот -O2 -march=native это ключ оптимизации, который
                                                    # был лучшим у меня по результатам первого скрипта.
                                                    # тебе нужно будет узнать, какой лучший у тебя, и заменить здесь на # свой. Всё остальное аналогично тому, как в optimizationLevelTest.

  # Программа time запускает какую-то другую программу (в нашем случае скомпилированную только что OptimizationOption)
  # и считает её время выполнения. После того, как программа, переданная time как аргумент (OptimizationOption) будет
  # исполнена, time выведет на консоль время, затраченное на исполнение.
  time -p ./OptimizationOption
done  # конец тела цикла

# по окончании цикла, выводим Done.
echo "Done"
