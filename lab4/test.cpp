#include <iostream>

/*
 * Объявляем здесь прототипы функций (function signatures, можно погуглить, если что).
 * Делается это для того, чтобы компилятор увидел их до того, где они впервые используются в коде.
 * Так как реализации этих двух функций у нас в конце файла, а используются в коде они раньше:
 * в main() идёт вызов функции calculate(), которая реализована ниже. Но т.к. здесь у нас есть сигнатура calculate(),
 * то компилятор, когда встретит её, сначала отдельно пройдётся по файлу, найдёт реализацию её (внизу) и подставит сюда.
 * Тогда, когда он пойдёт снова уже компилировать, и увидит в main() вызов calculate(), он будет уже иметь к этому
 * месту реализацию функции calculate() и сможет сделать то, что требуется.
 */
void calculate(long unsigned int);
double factorial(long unsigned n);

/* Точка входа в программу */
int main (void)
{
  /*
   * Дважды вызываем нашу функцию, передавая ей огромный параметр.
   * Формат записи 25e8 означает, что это 25 * 10^8. 10e8 = 10 * 10^8. Здесь e означает степень десятки, на которую,
   * десятку, мы умножаем число слева.
   */
  calculate(25e8);
  calculate(10e8);

  return 0;
}

/*
 * Эта функция просто выполняет несложные вычисления, используя цикл, деления, умножения, и, главное, вывод на экран.
 */
void calculate(long unsigned int count)
{
  /* Здесь будем хранить результат вычислений. Результат будет большой. Выводится будет тоже в формате 10e10*/
  double res = 0.0;
  /*
   * Переменная-счётчик для цикла. Цикл у нас от 1 до count (переменная-аргумент функции), а т.к. count у нас
   * это long unsigned int, то и i должен быть такого же типа, чтобы иметь возможность принимать значение count.
   */
  long unsigned int i;

  /* Основной цикл программы. От 1 до count включительно (т.к. i <= count).*/
  for (i = 1; i <= count; ++i) {
    /*
     * Здесь мы вызываем каждый раз (а всего таких раз = count!) функцию factorial, описанную ниже.
     * А результат её постоянно _добавляем_ в res. В качестве параметра мы передаём в factorial
     * остаток от деления i на 5 (i % 5). Это число в большинстве случаев гораздо меньше, чем будет i.
     * Иначе, если бы ещё и factorial вызывался с параметром i, то мы бы выполняли эти все вычисления наверное год.
     */
    res += factorial(i % 5);
  }

  /*
   * Необходимый вывод на экран. Без него, компилятор при любом ключе оптимизации просто не станет ничего считать,
   * и программа будет завершаться очень быстро с любым ключём, потому что по сути, если мы никак не используем
   * результат этих вычислений (не выводим, как здесь, на поток вывода, или, например, не выводим в файл или ещё куда),
   * то и тратить ресурсы на это не стоит. Поступает компилятор, конечно, правильно, это и есть базовая оптимизация.
   * Но нам нужно всё-таки проверить и другую оптимизацию, поэтому оставляем здесь вывод на экран.
   */
  std::cout << "Calculated: " << res << std::endl;
}

/*
 * Функция, вычисляющая факториал числа, переданного в аргумента. Напомню, что n! = 1*2*3*4*5*...*n.
 */
double factorial(long unsigned n)
{
  /*
   * Переменная, в которой будет храниться вычисленный факториал. Т.к. любой факториал числа включает в себя первый
   * множитель единицу, то можно инициализировать x единицей, а цикл, в котором будем умножать, начать не с 1, а с 2.
   */
  double x = 1.0;
  /*
   * Аналогично i в функции calculate().
   * Переменная-счётчик для цикла. Цикл у нас от 1 до count (переменная-аргумент функции), а т.к. count у нас
   * это long unsigned int, то и i должен быть такого же типа, чтобы иметь возможность принимать значение count.
   */
  long unsigned int i;

  /*
   * Собственно, цикл от двух до n включительно. Считаем факториал, циклично умножая x (изначально равен 1) на i,
   * которая принимает по очереди все значения от 2 до n включительно. Так реализуется факториал: n! = 1*2*3*4*...*n.
   */
  for (i = 2; i <= n; ++i) {
    /* Конструкция x *= i это то же самое, что и x = x * i, просто короче записанная. */
    x *= i;
    /* Аналогично, x += i <=> x = x + i; x -= i <=> x = x - i; x /= i <=> x = x / i; x &= i <=> x = x & i; и т.д. */
  }

  /* Возвращаем вычисленный факториал. */
  return x;
}
